# Action Execution Server Startup in Non-CLI Modes

Based on exploration of the OpenHands codebase, this document explains how the action execution server gets started up in non-CLI modes:

## Action Execution Server Startup in Non-CLI Modes

In non-CLI modes (like GUI mode), the **Action Execution Server** is started on-demand when a user session/conversation is created. Here's the flow:

### 1. **What is the Action Execution Server?**
The Action Execution Server is a FastAPI-based REST API defined in `openhands/runtime/action_execution_server.py`. It receives agent actions (bash commands, Python code, file operations, browsing actions, etc.), executes them in the runtime environment, and returns observations.

### 2. **When Does It Start?**
The server starts when:
1. A user creates a new conversation/session through the web interface
2. The `AgentSession.start()` method is called
3. This triggers `AgentSession._create_runtime()` 
4. The runtime's `connect()` method is invoked
5. This finally starts the action execution server

### 3. **How Different Runtimes Start the Server:**

**Docker Runtime** (`DockerRuntime`):
- Uses `docker.containers.run()` to start a container
- Runs the server inside the container with the command generated by `get_action_execution_server_startup_command()`
- The container is started with the action execution server as the main process

**Local Runtime** (`LocalRuntime`):
- Uses `subprocess.Popen()` to start the server as a local process
- Runs directly on the host machine without containerization
- Useful for development and testing

**Remote Runtime** (`RemoteRuntime`):
- Makes HTTP requests to a remote runtime service
- The remote service handles starting the action execution server
- Used for distributed/cloud deployments

**Kubernetes Runtime** (`KubernetesRuntime`):
- Creates Kubernetes pods/deployments to run the server
- Similar to Docker but orchestrated by Kubernetes

### 4. **Command Generation:**
The startup command is generated by `get_action_execution_server_startup_command()` in `openhands/runtime/utils/command.py`, which creates something like:

```bash
python -u -m openhands.runtime.action_execution_server <port> \
  --working-dir <workspace_path> \
  --plugins <plugin_list> \
  --username <username> \
  --user-id <user_id> \
  [--no-enable-browser]
```

### 5. **Key Insight:**
The action execution server is **not** a standalone service that runs independently. Instead, it's started on-demand for each conversation/session and managed by the runtime implementation. This allows for:
- Isolation between different user sessions
- Dynamic resource allocation
- Easy cleanup when sessions end
- Support for different deployment models (local, containerized, distributed)

The server runs until the session is closed or the runtime is shut down, at which point the process/container is terminated.

## Code References

- Action Execution Server: `openhands/runtime/action_execution_server.py`
- Command Generation: `openhands/runtime/utils/command.py`
- Session Management: `openhands/server/session/agent_session.py`
- Runtime Implementations:
  - Docker: `openhands/runtime/impl/docker/docker_runtime.py`
  - Local: `openhands/runtime/impl/local/local_runtime.py`
  - Remote: `openhands/runtime/impl/remote/remote_runtime.py`
  - Kubernetes: `openhands/runtime/impl/kubernetes/kubernetes_runtime.py`